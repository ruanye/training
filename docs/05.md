# 鸿蒙开发介绍

##  知识地图

![](/images/zhishi.png)


## DevEco Studio

面向全场景多设备，提供一站式的分布式应用开发平台，支持分布式多端开发、分布式多端调测、多端模拟仿真，提供全方位的质量与安全保障。

## ArkTS

ArkTS是鸿蒙生态的应用开发语言。它在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了声明式UI、状态管理等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用。


## ArkUI

ArkUI是一套构建分布式应用界面的声明式UI开发框架。它使用极简的UI信息语法、丰富的UI组件、以及实时界面预览工具，帮助您提升HarmonyOS应用界面开发效率。


## ArkCompiler

ArkCompiler是华为自研的统一编程平台，包含编译器、工具链、运行时等关键部件，支持高级语言在多种芯片平台的编译与运行，并支撑应用和服务运行在手机、个人电脑、平板、电视、汽车和智能穿戴等多种设备上的需求。


## DevEco Testing

提供 HarmonyOS 应用及原子化服务的兼容性、稳定性、性能、功耗、安全、跨端流转等测试标准和测试服务。

## 开发 TodoListApp。

#### 准备步骤

首先创建一个新的项目，名称为 TodoListApp。

![图片描述](https://doc.shiyanlou.com/courses/27827/1693782/9a047c855501c512d73fbdeec8c01f0a-0)

在工程 `pages` 目录中，选中 `Index.ets`，点击鼠标右键 > Refactor > Rename，改名为 `ToDoListPage.ets`。改名后，在工程 `entryability` 目录下，把 `EntryAbility.ts` 文件中 `windowStage.loadContent` 方法的第一个参数修改为 `pages/ToDoList`。

```js
// EntryAbility.ts
onWindowStageCreate(windowStage: Window.WindowStage) {
  ...
  windowStage.loadContent('pages/ToDoList', (err, data) => {
    ...
  });
}
```

选中工程的 `ets` 目录，点击鼠标右键 > new> Directory，新建 `view` 文件夹。选中新建的 `view` 文件夹，点击鼠标右键 > new> ArkTS File，新建 `ToDoItem.ets` 文件。后续在此文件中封装自定义组件。

点击下载 [resources](https://labfile.oss.aliyuncs.com/courses/27827/resources.zip) 资源替换当前项目中的 `entry/src/mian/resources` 文件夹。

全部文件的创建完成后，`ets` 目录结构如下所示：

```bash
├──entry/src/main/ets      // 代码区
│  ├──entryability
│  │  └──EntryAbility.ts   // 程序入口类
│  ├──pages
│  │  └──ToDoListPage.ets  // 主页面
│  ├──view
│     └──ToDoItem.ets     // 自定义单项待办组件
└──entry/src/main/resources	  // 资源文件目录
```

#### 声明式UI基本概念

应用界面是由一个个页面组成，`ArkTS` 是由 `ArkUI` 框架提供，用于以声明式开发范式开发界面的语言。

声明式 UI 构建页面的过程，其实是组合组件的过程，声明式 UI 的思想，主要体现在两个方面：

- 描述 UI 的呈现结果，而不关心过程状态驱动视图更新
- 类似苹果的 `SwiftUI` 中通过组合视图 `View`，安卓`Jetpack Compose` 中通过组合 `@Composable` 函数，`ArkUI` 作为 HarmonyOS 应用开发的 UI 开发框架，其使用 `ArkTS` 语言构建自定义组件，通过组合自定义组件完成页面的构建。

#### 开发 ToDoItem 组件

ArkTS 通过 `struct` 声明组件名，并用 `@Component` 和@ `Entry` 装饰器，来构成一个自定义组件。`@Entry` 和 `@Component` 装饰的自定义组件是页面的入口，会在页面加载时首先进行渲染。

使用 `@Component` 装饰自定义组件 `ToDoItem`，在 `ToDoItem.ets` 写入如下代码：

```js
@Component
export default  struct ToDoItem {
   build(){
     // 在 build中进行 UI 构建
   }
}
```

![图片描述](https://doc.shiyanlou.com/courses/27827/1777363/4fe70d185425a9458266103585e44a8e-0)

由上图可见 `ToDoItem` 的布局，为两个元素横向排列，所以我们这里选择 `Row` 布局。

```js
@Component
export default  struct ToDoItem {
   @State isComplete : boolean = false; // 设置完成状态，默认为 false
   @State content:string ='待办事项'

   build(){
      Row() {
          Image($r('app.media.ic_default'))
            .objectFit(ImageFit.Contain)
            .width($r('app.float.checkbox_width'))
            .height($r('app.float.checkbox_width'))
            .margin($r('app.float.checkbox_margin')) // 图标
         Text(this.content)   // 待办事项文字
      }
   }
}
```

上面代码中的 `$r(...)` 的写法表示使用 [`resources` ](https://developer.harmonyos.com/cn/docs/documentation/doc-guides/resource-categories-and-access-0000001435940589) 中的资源，更详细的用法将在后续章节中进行讲解。

接下来在 `ToDoList` 引入 `ToDoItem` 自定义组件。让 `ToDoItem` 正常显示出来，首先我们在 `ToDoList.ets` 中写入代码。

```js
@Entry
@Component
struct ToDoListPage {
  build() {
  }
}
```

因为 `ToDoList.ets` 是入口组件，所以在这里添加了 `@Entry`。ToDoList 是纵向排列的，所以我们选择了 `Column` 布局。

![图片描述](https://doc.shiyanlou.com/courses/27827/1777363/966194d377288bef3e2b5b1222e020b9-0)

接下来我们修改 `ToDoList.ets` 代码，修改内容如下：

```js
import ToDoItem from '../view/ToDoItem';
@Entry
@Component
struct ToDoList {
  build() {
    Column(){
      ToDoItem()  // 显示 TODO item
    }
  }
}

```

打开预览，效果如下所示：

![图片描述](https://doc.shiyanlou.com/courses/27827/1777363/07dbf97287cd7da296a6aff51d2753c0-0)

#### 改变组件状态

通过控制 `isComplete`，可以控制 `ToDoItem` 的完成状态，并显示不同的组件展示效果。可以使用条件渲染 `if / else` 语法实现。

![图片描述](https://doc.shiyanlou.com/courses/27827/1777363/a0ec00b2d9ff21475898ba2e871e69f8-0)

下面是根据 `isComplete` 的状态来切换显示图片的代码：

```js
if (this.isComplete) {
  Image($r("app.media.ic_ok"))
    .objectFit(ImageFit.Contain)
    .width($r("app.float.checkbox_width"))
    .height($r("app.float.checkbox_width"))
    .margin($r("app.float.checkbox_margin"));
} else {
  Image($r("app.media.ic_default"))
    .objectFit(ImageFit.Contain)
    .width($r("app.float.checkbox_width"))
    .height($r("app.float.checkbox_width"))
    .margin($r("app.float.checkbox_margin"));
}
```

由于两个 `Image` 实现了很多相同的代码，ArkTS 提供了一个 `@Builder` 装饰器来修饰一个函数，快速生成布局内容，避免重复的 UI 描述内容。使用 `@Builder` 声明一个 `labelIcon` 函数，其参数是 `url`，代表要传给 `Image` 的图片路径。

```js
@Builder labelIcon(url) {
  Image(url)
    .objectFit(ImageFit.Contain)
    .width($r('app.float.checkbox_width'))
    .height($r('app.float.checkbox_width'))
    .margin($r('app.float.checkbox_margin'))
}
```

使用时只需要使用 `this` 关键字访问 `@Builder` 装饰的函数名，即可快速创建布局。

```js
if (this.isComplete) {
  this.labelIcon($r("app.media.ic_ok"));
} else {
  this.labelIcon($r("app.media.ic_default"));
}
```

为了使待办项更符合已完成效果，增加了相应的样式变化。通过三目运算符，根据状态变化来修改其透明度和文字样式。例如，`opacity` 控制透明度，`decoration` 控制文字是否有划线。最终通过 `isComplete` 的值来控制变化。

![图片描述](https://doc.shiyanlou.com/courses/27827/1777363/ad8d3598d4bf5daec05c85197f4408e3-0)

最后，为了实现与用户的交互效果，在组件上添加了 `onClick` 点击事件，当用户点击待办项时，数据 `isComplete` 的更改能够触发UI 的更新。修改 `ToDoItem` 代码如下。

```js
@Component
export default  struct ToDoItem {
   @State isComplete : boolean = false; // 设置完成状态，默认为 false
   @State content:string ='待办事项'
   // 图片
   @Builder labelIcon(icon: Resource) {
      Image(icon)
         .objectFit(ImageFit.Contain)
         .width($r('app.float.checkbox_width'))
         .height($r('app.float.checkbox_width'))
         .margin($r('app.float.checkbox_margin'))
   }
   build() {
      Row() {
         // 根据状态切换图片
         if (this.isComplete) {
            this.labelIcon($r('app.media.ic_ok'));
         } else {
            this.labelIcon($r('app.media.ic_default'));
         }

         Text(this.content)
            .fontSize($r('app.float.item_font_size'))
            .fontWeight('500')
            .opacity(this.isComplete?0.4 : 1) // 透明度
            .decoration({ type: this.isComplete ? TextDecorationType.LineThrough : TextDecorationType.None  }) // 根据状态判断文字是否显示中划线
      }
      .borderRadius('24')
      .backgroundColor($r('app.color.start_window_background'))
      .width('93.3%')
      .height($r('app.float.list_item_height'))
      // 点击事件切换状态
      .onClick(() => {
         this.isComplete = !this.isComplete;
      })
   }
}
```

打开预览，效果如下：

![图片描述](https://doc.shiyanlou.com/courses/27827/1777363/a4271731a7122bb45e7844de9c503bfa-0)

#### 循环渲染列表数据

为了实现动态数据渲染，我们要把 `ToDoItem` 组件中的 `@State content:string ='待办事项'` 改成 `private content?: string;`。这样 `ToDoItem` 组件就写完了。接下来，我们定义一些数据，然后对 `ToDoItem` 进行循环渲染。在 `ToDoList.ets` 中，我们用 `ForEach` 循环来显示 `ToDoList` 列表。`ToDoList.ets` 组件的代码如下：

```js
import ToDoItem from '../view/ToDoItem';
@Entry
@Component
struct ToDoList {
  // 定义循环用的数组数据
  @State total_Tasks:Array<string> = [
    '早起晨练',
    '准备早餐',
    '阅读名著',
    '学习ArkTS',
    '看剧放松'
  ]
  build() {
    Column(){
      // 渲染 todo 列表
      ForEach(this.total_Tasks, (item: string) => {
        ToDoItem({ content: item })
      }, (item: string) => JSON.stringify(item))
    }
  }
}
```

现在列表已经渲染出来了，接下来我们添加下标题，然后调整下列表项之间的间距。修改 `ToDoList` 组件代码，代码如下：

```js
// ToDoList.ets
import ToDoItem from '../view/ToDoItem';
@Entry
@Component
struct ToDoList {
  // 定义循环用的数组数据
  @State total_Tasks:Array<string> = [
    '早起晨练',
    '准备早餐',
    '阅读名著',
    '学习ArkTS',
    '看剧放松'
  ]
  build() {
    Column({space:16}){ // 设置列间距为15
      Text($r('app.string.page_title'))  // 设置标题和标题样式
        .fontSize($r('app.float.title_font_size'))
        .fontWeight(FontWeight.Bold)
        .lineHeight($r('app.float.title_font_height'))
        .width('80%')
        .margin({
          top: $r('app.float.title_margin_top'),
          bottom: $r('app.float.title_margin_bottom')
        })
        .textAlign(TextAlign.Start)
      // 渲染 todo 列表
      ForEach(this.total_Tasks, (item: string) => {
        ToDoItem({ content: item })
      }, (item: string) => JSON.stringify(item))
    }
  }
}
```

大功告成，我们从头到尾完成了一个 TodoList 项目。

