# 蓝桥杯 WEB 赛项真题解析

## html 和 css3

- 高频考点 grid 和 flex

1. [电影院排座位](https://www.lanqiao.cn/problems/5133/learning/)

- 考察: `flex/gird` 、 `nth-child`、`nth-of-type`
- 解题思路：关键点 8 个⼀排、 第 2 、6 外边距 30px
- 答案：

```css
/* gird 布局答案 */
.seat-area {
  margin-top: 50px; /* 设置顶部外边距为50像素 */
  display: grid; /* 将该元素设置为⽹格布局 */
  grid-template-columns: repeat(8, auto); /* 设置8列⾃动宽度的⽹格布局 */
  gap: 10px; /* 设置⽹格之间的间隙为10像素 */
}
/* 以下样式规则定义了每8个座位中第2个和第6个座位的右侧外边距  */
.seat:nth-of-type(8n + 2) {
  margin-right: 20px; /* 设置第2个和第6个座位的右侧外边距为20像素 */
}

.seat:nth-of-type(8n + 6) {
  margin-right: 20px; /* 设置第2个和第6个座位的右侧外边距为20像素 */
}
```

```css
/* flex 布局答案 */
/* seat-area 座位区域 */
.seat-area {
  display: flex;
  flex-wrap: wrap;
  margin-top: 40px; /* 顶部外边距为 40 像素 */
}
/* seat-area 座位 */
.seat {
  margin-left: 10px; /* 左外边距为 10 像素 */
  margin-top: 10px; /* 顶部外边距为 10 像素 */
}

.seat:nth-child(8n + 1) {
  margin-left: 0; /* 每⾏的第⼀个座位的左外边距为 0 */
}

.seat:nth-child(8n + 2) {
  margin-right: 20px; /* 每⾏的第⼆个座位的右外边距为 20 像素 */
}

.seat:nth-child(8n + 7) {
  margin-left: 30px; /* 每⾏的第七个座位的左外边距为 30 像素 */
}
```

- 知识点解析：

- grid 布局：

- `grid-template-columns` ：⽤于定义⽹格列的⼤⼩和数量。
- `grid-gap`：⽤于定义⽹格单元格之间的间距。

- `nth-of-type` 是⼀个 CSS 伪类选择器，⽤于选取⼀组相同类型的元素中的第 n 个元素。
   具体⽽⾔，`:nth-of-type(n)` 匹配其⽗元素下第 ``n` 个同类型的元素。该选择器接受⼀个参数，可以是
   ⼀个具体的数字、关键字 `odd` 或 `even` ，或者公式 `an + b` 。
   以下是⼀些示例：

- `:nth-of-type(2)` 选择其⽗元素下的第⼆个同类型元素。
- `:nth-of-type(odd)` 选择其⽗元素下的所有奇数同类型元素。
- `:nth-of-type(even)` 选择其⽗元素下的所有偶数同类型元素。
- `:nth-of-type(3n + 1)` 选择其⽗元素下每隔 3 个同类型元素中的第⼀个。
  该伪类选择器可以⽤于选择列表、⽹格和其他具有相同类型元素的结构。

- `nth-child` 是⼀个 CSS 伪类选择器，⽤于选择指定元素的⼦元素，它的语法如下：
   `:nth-child(an+b)`
   其中， `a` 和 `b` 是两个可选参数， `n` 表示⼀个整数（0, 1, 2, ...），表示元素在其⽗元素中的位置。 `an+b` 则表示⼀系列满⾜这个公式的元素，其中 a 和 b 为数字，表示这些元素的位置。例如， `2n+1` 表示所有奇数位置的元素。
   下⾯是⼀些常⽤的 `nth-child` 选择器：

- `:nth-child(n)` ：匹配⽗元素的所有⼦元素。
- `:nth-child(even)` ：匹配⽗元素的偶数⼦元素。
- `:nth-child(odd)` ：匹配⽗元素的奇数⼦元素。
- `:nth-child(3)` ：匹配⽗元素的第三个⼦元素。
- `:nth-child(3n)` ：匹配⽗元素的第 3、6、9、12... 个⼦元素。
- `:nth-child(3n+1)` ：匹配⽗元素的第 1、4、7、10... 个⼦元素。
- `:nth-child(-n+4)` ：匹配⽗元素的前 4 个⼦元素。

2. 植物灌溉 

- 考点：`grid-area`

```css
.treatment {
  grid-area: 1 / 2 / 4 / 6;
}
.treatment {
  grid-row: 1 / 4;
  grid-column: 2 / 6;
}
```
- 知识点解析：
   
   如果指定了 4 个 `<grid-line>` 值，`grid-row-start` 则会被设为第一个值，`grid-column-start` 为第二个值，`grid-row-end` 为第三个值，`grid-column-end` 为第四个值。

## 函数封装题

1. [抢红包了](https://www.lanqiao.cn/courses/18421/learning/?id=867687)

```js
function randomAllocation(total, n) {
  var remain = total;
  var ret = []; // 最终返回的数据

  // 分配金额循环 n-1 次
  for (let i = 0; i < n - 1; i++) {
    // m 为每次分配的红包金额，取 0.1 和 remain 中间的随机数
    let m =
      Math.ceil(Math.random() * 100 * (remain - (n - (i + 1)) * 0.01)) / 100;
    ret.push(m);
    remain -= m; // 剩余量每次减去 M
  }
  ret.push(Number(remain.toFixed(2)));
  return ret;
}
```

2. [版本比较器](https://www.lanqiao.cn/courses/18421/learning/?id=863387)

```js
function compareVersion(version1, version2) {
  const regex = /^\d+(\.\d+){0,2}$/; // 匹配 1~3 个数字，中间用 . 分隔的正则表达式
  if (!regex.test(version1) || !regex.test(version2)) {
    return "error"; // 如果版本号格式不正确，则返回 "error"
  }

  const v1Arr = version1.split(".").map(Number); // 将 version1 按 . 分隔后，将每个部分转换为数字
  const v2Arr = version2.split(".").map(Number); // 将 version2 按 . 分隔后，将每个部分转换为数字
  const len = Math.max(v1Arr.length, v2Arr.length); // 获取两个版本数组的最大长度

  for (let i = 0; i < len; i++) {
    const v1 = i < v1Arr.length ? v1Arr[i] : 0; // 如果 version1 的长度大于 i，则获取第 i 个部分，否则为 0
    const v2 = i < v2Arr.length ? v2Arr[i] : 0; // 如果 version2 的长度大于 i，则获取第 i 个部分，否则为 0

    if (v1 > v2) {
      return 1; // 如果 version1 大于 version2，则返回 1
    } else if (v1 < v2) {
      return -1; // 如果 version1 小于 version2，则返回 -1
    }
  }
  return 0; // 如果两个版本号相等，则返回 0
}
```

## DOM 操作题目

1. [图片水印生成](https://www.lanqiao.cn/problems/5134/learning/)

- 考察： dom 操作、css 、 css3 常⻅属性

```js
// 通过 for 循环⽣成指定数量的 span 元素，并将它们添加到容器中
for (let index = 0; index < count; index++) {
  // 使⽤传⼊的参数设置 span 元素的⽂本内容、颜⾊、旋转⻆度和透明度，并添加到容器中
  container.innerHTML += `<span style="color:${color};transform: rotate(${deg}deg);opacity:${opacity}">${text}</span>`;
  // 返回添加了 span 元素的容器
}
```

答案 2 ：

```js
// 使⽤ repeat() ⽅法创建⼀个包含指定数量 span 元素的字符串，并为每个元素设置⽂本内容、颜⾊、旋转⻆度和
const spans =
  `<span style="color:${color};transform: rotate(${deg}deg);opacity:${opacity}">${text}</span>`.repeat(count);
// 将包含所有 span 元素的字符串添加到容器中
container.innerHTML = spans;
// 返回添加了 span 元素的容器
return container;
```

## es6

1. [收集帛书碎⽚](https://www.lanqiao.cn/problems/5135/learning)

- 考察：数组⽅法、数组去重、扩展运算符 
- 解题思路：⼊参是⼀个⼆维数组，转换成⼀维数组，去重

答案 1 ：

```js
const result = [...new Set(puzzles.flat())];
return result;
```

答案 2 ：

```js
let result = [];
for (let index = 0; index < puzzles.length; index++) {
  const item = puzzles[index];
  result.push(...item);
}
result = [...new Set(result)];
return result;
```

- 知识点解析： `flat()` 是 `JavaScript` 数组的⼀个⽅法，⽤于将多维数组扁平化为⼀维数组。

该⽅法可以接收⼀个整数参数，表示要扁平化的嵌套层数。例如，如果传递参数 2 ，则会将⼆维数组扁 平化为⼀维数组，但不会将三维及以上的数组扁平化。

如果不传递参数，则默认值扁平化⼀层。如果数组中有空位（即未定义的元素），则 `ﬂat()` ⽅法默认会将其删除，返回⼀个新的不含空位的数组。

以下是 `ﬂat()` ⽅法的示例⽤法：

```js
const arr1 = [1, 2, [3, 4]];

arr1.flat(); // [1, 2, 3, 4]

const arr2 = [1, 2, [3, 4, [5, 6]]];

arr2.flat(); // [1, 2, 3, 4, [5, 6]]

const arr3 = [1, 2, [3, 4, [5, 6]]];

arr3.flat(2); // [1, 2, 3, 4, 5, 6]
```

在上⾯的示例中，`arr1` 和 `arr2` 数组中的嵌套数组都被扁平化为了⼀维数组。在 `arr3` 中，`flat(2)` ⽅法将嵌套数组扁平化了两层，⽣成了⼀个包含所有元素的⼀维数组。
`Set` 是 `JavaScrip`t 中的⼀种数据结构，它类似于数组，但是它的值是唯⼀的，不会有重复的值。


在ES6中，"..."（三个连续的点）是一个扩展运算符（Spread Operator）的语法。它有以下几种主要的作用：

- 数组的展开：使用扩展运算符可以将一个数组展开为独立的元素。例如：

```javascript
const arr = [1, 2, 3];
console.log(...arr); // 输出: 1 2 3
```

-  函数调用时的参数传递：扩展运算符可以用于将一个数组作为参数传递给函数，并展开为独立的参数。例如：

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 输出: 6
```

- 对象的展开：扩展运算符可以用于将一个对象展开为另一个对象的属性。例如：

```javascript
const obj1 = { x: 1, y: 2 };
const obj2 = { ...obj1, z: 3 };
console.log(obj2); // 输出: { x: 1, y: 2, z: 3 }
```

- 数组和对象的浅拷贝：通过扩展运算符可以创建数组和对象的浅拷贝。例如：

```javascript
const arr = [1, 2, 3];
const arrCopy = [...arr];

const obj = { x: 1, y: 2 };
const objCopy = { ...obj };
```

需要注意的是，扩展运算符只能在可迭代对象（如数组）或具有可枚举属性的对象上使用。它提供了一种方便的方式来处理数组和对象的展开、合并和复制操作，使代码更加简洁和易读。

2. [萌宠小玩家](https://www.lanqiao.cn/courses/18421/learning/?id=911416)

- 考察： `class`、数组、dom 操作

```js
 // 验证是否已经起名
  verifyName() {
    this.name = nickname.value;
    if (!this.name) {
      vail_name.style.display = "block";
    } else {
      vail_name.style.display = "none";
    }
  }
  showLog(record) {
    if (this.logList.length == 10) {
      this.logList.pop();
      this.logList.unshift(record);
    } else {
      this.logList.unshift(record);
      console.log(this.logList);
    }
    let logHtmlStr = this.logList
      .map((item) => {
        return `<div>${item}</div>`;
      })
      .join("");
    list.innerHTML = logHtmlStr;
  }
```

## element-ui 题目

1. [element-ui 轮播图组件二次封装](https://www.lanqiao.cn/courses/18421/learning/?id=855653)

考察：`element-ui` 轮播图组件、vue 基础知识

```html
<template>
  <!-- 省略其他代码... -->
  <li
    class="point"
    v-for="(_, index) in images"
    :key="index"
    :class="{ active: currentIndex === index }"
    @click="setActive(index)"
  ></li>
  <!-- 省略其他代码... -->
</template>

<script>
  data() {
     return {
       currentIndex: 0,
     };
   },
   methods: {
     carouselChange(index) {
       this.currentIndex = index;
     },
     setActive(index) {
       this.$refs.carousel.setActiveItem(index);
     },
   },
</script>
```


## echarts 题目 

1. [天气趋势](https://www.lanqiao.cn/problems/2466/learning)

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>天气统计</title>
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"
    />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <script src="./js/axios.js"></script>
    <script src="js/vue.min.js" type="text/javascript" charset="utf-8"></script>
    <script
      src="js/echarts.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
  </head>

  <body>
    <div id="app">
      <div class="top-bar">2022年Y城全年温度统计图</div>
      <!-- 主体 -->
      <div class="container">
        <!-- 月份 -->
        <div class="month">
          <ul>
            <li
              v-for="(val, key, index) in monthList"
              :class="activeMonth===index+1?'active':''"
              @click="changeMonth(index)"
            >
              {{val}}
            </li>
          </ul>
        </div>
        <!-- 未来七天和本月tab切换框，只有当前月才显示 -->
        <div class="chart">
          <div id="currentMonth" v-if="currentMonth==activeMonth">
            <div class="title">
              <h3>{{typeTitle}}</h3>
              <div class="type">
                <span
                  id="seven"
                  :class="type==1?'active':''"
                  @click="changeType(1)"
                  >未来7天</span
                >
                <span
                  id="current"
                  :class="type==2?'active':''"
                  @click="changeType(2)"
                  >本月</span
                >
              </div>
            </div>
          </div>
          <div id="chart"></div>
        </div>
      </div>
    </div>
  </body>
</html>
<script>
  var vm = new Vue({
    el: "#app",
    data: {
      type: 2, //本月和未来七天type，默认显示本月
      chart: null, // 图表
      chartOptions: null, // 图表配置项
      typeTitle: "本月天气",
      monthList: {
        January: "1月",
        February: "2月",
        March: "3月",
        April: "4月",
        May: "5月",
        June: "6月",
        July: "7月",
        August: "8月",
        September: "9月",
        October: "10月",
        November: "11月",
        December: "12月",
      },
      currentMonth: 0, // 当前月份
      activeMonth: 1, // 点击的月份
      currentDay: null, // 今天
      weatherData: [], // 天气数据
      seriesData: [], // Y 轴坐标数据
      xAxisdata: [], // x轴坐标数据
      months: [], // 把月份放进一个数组方便取数据
    },
    async created() {
      this.weatherData = await axios
        .get("./js/weather.json")
        .then((res) => res.data);
      //设置月份数组
      for (let key in this.monthList) {
        this.months.push(key);
      }
      let date = new Date();
      // 设置当前月份
      this.currentMonth = date.getMonth() + 1;
      // 获取今天的日期
      this.currentDay = date.getDate();
      // 设置默认显示一月份的天气
      this.chartOptions.series[0].data = this.weatherData[0][this.months[0]];
      this.chart.setOption(this.chartOptions);
    },
    mounted: function () {
      // 初始化 echarts
      this.$nextTick(() => {
        this.initChart();
      });
    },
    methods: {
      initChart() {
        // 初始化图表
        this.chart = echarts.init(document.getElementById("chart"));
        // 配置项
        this.chartOptions = {
          grid: {
            top: 35,
            bottom: 5,
            left: 10,
            right: 10,
            containLabel: true,
          },
          tooltip: {
            trigger: "axis",
            axisPointer: {
              lineStyle: {
                color: {
                  type: "linear",
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: "rgba(255,255,255,0)", // 0% 处的颜色
                    },
                    {
                      offset: 0.5,
                      color: "rgba(255,255,255,1)", // 100% 处的颜色
                    },
                    {
                      offset: 1,
                      color: "rgba(255,255,255,0)", // 100% 处的颜色
                    },
                  ],
                  global: false, // 缺省为 false
                },
              },
            },
          },
          xAxis: [
            {
              type: "category",
              boundaryGap: false,
              axisLabel: {
                formatter: "{value}",
                fontSize: 12,
                margin: 20,
                textStyle: {
                  color: "#bfbfbf",
                },
              },
              axisLine: {
                lineStyle: {
                  color: "#e9e9e9",
                },
              },
              splitLine: {
                show: true,
                lineStyle: {
                  color: "#f7f7f7",
                },
              },
              axisTick: {
                show: false,
              },
              // x 轴显示的数据，即天数
              data: [
                1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
              ],
            },
          ],
          yAxis: [
            {
              boundaryGap: false,
              type: "value",
              axisLabel: {
                textStyle: {
                  color: "#bfbfbf",
                },
                formatter: `{value}\u2103`,
              },
              nameTextStyle: {
                color: "# fff ",
                fontSize: 12,
                lineHeight: 40,
              },
              splitLine: {
                lineStyle: {
                  color: "#f7f7f7",
                },
              },
              axisLine: {
                show: true,
                lineStyle: {
                  color: "#e9e9e9",
                },
              },
              axisTick: {
                show: false,
              },
            },
          ],
          series: [
            {
              name: "天气",
              type: "line",
              smooth: false,
              showSymbol: false,
              symbolSize: 0,
              zlevel: 3,
              itemStyle: {
                color: "#ff6600",
                borderColor: "#a3c8d8",
              },
              lineStyle: {
                normal: {
                  width: 3,
                  color: "#ff6600",
                },
              },
              areaStyle: {
                normal: {
                  color: new echarts.graphic.LinearGradient(
                    0,
                    0,
                    0,
                    1,
                    [
                      {
                        offset: 0,
                        color: "#ff6600",
                      },
                      {
                        offset: 0.8,
                        color: "#ff9900",
                      },
                    ],
                    false
                  ),
                },
              },
              //  Y 轴显示的数据，即温度数据
              data: [
                23, 19, 30, 31, 18, 20, 16, 15, 23, 27, 29, 30, 32, 23, 25, 20,
                22, 24, 34, 24, 21, 26, 23, 24, 25, 23, 25, 28, 32, 20,
              ],
            },
          ],
        };

        // 调用此方法设置 echarts 数据
        this.chart.setOption(this.chartOptions);
      },
      // 切换月份
      changeMonth: function (item) {
        this.typeTitle = "本月天气";
        this.type = 2;
        // 点击月的数据
        this.activeMonth = item + 1;
        this.xAxisdata = [];
        this.seriesData = this.weatherData[item][this.months[item]];

        for (let index = 0; index < this.seriesData.length; index++) {
          this.xAxisdata.push(index + 1);
        }
        this.chartOptions.xAxis[0].data = this.xAxisdata;
        this.chartOptions.series[0].data = this.seriesData;
        this.chart.setOption(this.chartOptions);
      },
      // 切换未来七天天气和本月天气
      changeType: function (item) {
        this.type = item;
        console.log(this.type);
        // 本月天气数据
        let currentMonthData =
          this.weatherData[this.currentMonth - 1][
            this.months[this.currentMonth - 1]
          ];
        if (item == 1) {
          this.typeTitle = "未来7天天气";
          let seven1 = currentMonthData.slice(
            this.currentDay - 1,
            this.currentDay + 6
          );
          let seven2 = [];
          this.xAxisdata = [];
          if (seven1.length < 7) {
            let nextMonth = this.month + 1;
            let nextMonthData =
              this.weatherData[nextMonth - 1][this.months[nextMonth - 1]];
            seven2 = nextMonthData.slice(0, 7 - seven1.length);
            // 本月如果剩余小于七天，先放本月天数
            for (let index = 0; index < seven1.length; index++) {
              this.xAxisdata.push(
                `${this.currentMonth}/${this.currentDay + index}`
              );
            }
            // 本月剩余如果大于七天，剩余的放下个月天数
            for (let index = 0; index < 7 - seven1.length; index++) {
              this.xAxisdata.push(`${this.currentMonth + 1}/${index}`);
            }
          } else {
            for (let index = 0; index < 7; index++) {
              this.xAxisdata.push(
                `${this.currentMonth}/${this.currentDay + index}`
              );
            }
          }
          this.nextSevenDays = [...seven1, ...seven2];
          this.chartOptions.xAxis[0].data = this.xAxisdata;
          this.chartOptions.series[0].data = this.nextSevenDays;
          this.chart.setOption(this.chartOptions);
        } else {
          this.typeTitle = "本月天气";
          this.xAxisdata = [];
          for (let index = 0; index < currentMonthData.length; index++) {
            this.xAxisdata.push(index + 1);
          }
          this.chartOptions.xAxis[0].data = this.xAxisdata;
          this.chartOptions.series[0].data = currentMonthData;

          this.chart.setOption(this.chartOptions);
        }
      },
    },
  });
</script>
```

## vue 题目



## node 题目

1. [找到未引用的图片](https://www.lanqiao.cn/courses/18421/learning/?id=867689)

```js
const findUnlinkImages = async function () {
  const unlinkImages = []; // 未被任何 md 文件引用的图片的数组
  // TODO 请通过 Node.js 在此处继续完成代码编写
  const articles = await traversalDir(articlesPath);
  for (let i = 0; i < articles.length; i++) {
    const filename = articles[i];
    const filedir = path.join(articlesPath, filename);
    const stats = await fs.statSync(filedir); // 判断目标是否为文件
    if (stats.isFile()) {
      const md = fs.readFileSync(filedir, "utf8");
      searchImage(md); // 检索出文章内的图片链接
    }
  }
  useImgs = [...new Set(useImgs)]; // 去重，非必要
  const allNames = await traversalDir(imagesPath);
  const allImgs = await getAllImages(allNames); // 获取全部图片
  let diff = allImgs
    .concat(useImgs)
    .filter((x) => !allImgs.includes(x) || !useImgs.includes(x)); // 取差集，最好是用 ES7 的 includes；ES6 可以用 Array.from结合Set；ES5 可以用 indexOf
  for (let i = 0; i < diff.length; i++) {
    // fs.unlinkSync(path.join(imagesPath, diff[i])) // 删除文件
    unlinkImages.push(diff[i]);
  }
  // console.log(`找到了 ${diff.length} 张无效图片`);
  // 获取全部图片的相对地址
  async function getAllImages(res) {
    return res.map((x) => "../images/" + x);
  }
  // TODO-END
  return unlinkImages; // 此处应返回一个数组，如不明白，请仔细阅读题目
};
```
